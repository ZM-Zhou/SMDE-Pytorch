import os
from collections import Counter

import numpy as np
import h5py
from PIL import Image, ImageFile
from scipy.io import loadmat

ImageFile.LOAD_TRUNCATED_IMAGES = True


def get_input_img(path, color=True):
    """Read the image in KITTI."""
    img = Image.open(path)
    if color:
        img = img.convert('RGB')
    return img


def get_intrinsic(path):
    """Read the intrinsic matrix of KITTI LEFT color camera."""
    calib = read_calib_file(os.path.join(path, 'calib_cam_to_cam.txt'))
    intrinsic_02 = calib['P_rect_02'].reshape(3, 4)
    return intrinsic_02


def get_input_depth(path, date_path, side='l'):
    """Read the depth from velodyne data of KITTI."""
    return generate_depth_map(date_path, path, 2 if side == 'l' else 3)


def get_input_depth_make3d(path):
    m = loadmat(path)
    pos3dgrid = m['Position3DGrid']
    depth = pos3dgrid[:, :, 3]
    return depth


def read_calib_file(path):
    """Read KITTI calibration file (from https://github.com/hunse/kitti)"""
    float_chars = set('0123456789.e+- ')
    data = {}
    with open(path, 'r') as f:
        for line in f.readlines():
            key, value = line.split(':', 1)
            value = value.strip()
            data[key] = value
            if float_chars.issuperset(value):
                # try to cast to float array
                try:
                    data[key] = np.array(list(map(float, value.split(' '))))
                except ValueError:
                    # casting error: data[key] already eq. value, so pass
                    pass
    return data


def load_velodyne_points(filename):
    """Load 3D point cloud from KITTI file format (adapted from
    https://github.com/hunse/kitti)"""
    points = np.fromfile(filename, dtype=np.float32).reshape(-1, 4)
    points[:, 3] = 1.0  # homogeneous
    return points


def sub2ind(matrixSize, rowSub, colSub):
    """Convert row, col matrix subscripts to linear indices (adapted from
    https://github.com/nianticlabs/monodepth2)"""
    m, n = matrixSize
    return rowSub * (n - 1) + colSub - 1


def generate_depth_map(calib_dir, velo_filename, cam=2, vel_depth=False):
    """Generate a depth map from velodyne data for kitti (adapted from
    https://github.com/nianticlabs/monodepth2)"""
    # load calibration files
    cam2cam = read_calib_file(os.path.join(calib_dir, 'calib_cam_to_cam.txt'))
    velo2cam = read_calib_file(os.path.join(calib_dir,
                                            'calib_velo_to_cam.txt'))
    velo2cam = np.hstack(
        (velo2cam['R'].reshape(3, 3), velo2cam['T'][..., np.newaxis]))
    velo2cam = np.vstack((velo2cam, np.array([0, 0, 0, 1.0])))

    # get image shape
    im_shape = cam2cam['S_rect_02'][::-1].astype(np.int32)

    # compute projection matrix velodyne->image plane
    R_cam2rect = np.eye(4)
    R_cam2rect[:3, :3] = cam2cam['R_rect_00'].reshape(3, 3)
    P_rect = cam2cam['P_rect_0' + str(cam)].reshape(3, 4)
    P_velo2im = np.dot(np.dot(P_rect, R_cam2rect), velo2cam)

    # load velodyne points and remove all behind image plane (approximation)
    # each row of the velodyne data is forward, left, up, reflectance
    velo = load_velodyne_points(velo_filename)
    velo = velo[velo[:, 0] >= 0, :]

    # project the points to the camera
    velo_pts_im = np.dot(P_velo2im, velo.T).T
    velo_pts_im[:, :2] = velo_pts_im[:, :2]\
        / velo_pts_im[:, 2][..., np.newaxis]

    if vel_depth:
        velo_pts_im[:, 2] = velo[:, 0]

    # check if in bounds
    # use minus 1 to get the exact same value as KITTI matlab code
    velo_pts_im[:, 0] = np.round(velo_pts_im[:, 0]) - 1
    velo_pts_im[:, 1] = np.round(velo_pts_im[:, 1]) - 1
    val_inds = (velo_pts_im[:, 0] >= 0) & (velo_pts_im[:, 1] >= 0)
    val_inds = val_inds & (velo_pts_im[:, 0] < im_shape[1]) \
        & (velo_pts_im[:, 1] < im_shape[0])
    velo_pts_im = velo_pts_im[val_inds, :]

    # project to image
    depth = np.zeros((im_shape[:2]))
    depth[velo_pts_im[:, 1].astype(np.int), velo_pts_im[:, 0].astype(np.int)]\
        = velo_pts_im[:, 2]

    # find the duplicate points and choose the closest depth
    inds = sub2ind(depth.shape, velo_pts_im[:, 1], velo_pts_im[:, 0])
    dupe_inds = [item for item, count in Counter(inds).items() if count > 1]
    for dd in dupe_inds:
        pts = np.where(inds == dd)[0]
        x_loc = int(velo_pts_im[pts[0], 0])
        y_loc = int(velo_pts_im[pts[0], 1])
        depth[y_loc, x_loc] = velo_pts_im[pts, 2].min()
    depth[depth < 0] = 0

    return depth


def get_camera_params(path):
    '''
    Read the intrinsic/extrinsic matrix from Cityscapes dataset's npy
    file, which is generated by ./tools/bulid_CS_matrx.py
    ----------
    path: str
        The path of npy file

    Returns
    -------
    intrinisc/extrinsic matrix: numpy Array
    '''
    trans_mat = np.load(path)
    ex_mat = np.eye(4)
    in_mat = trans_mat
    ex_mat[0, 3], in_mat[0, 3] = in_mat[0, 3], ex_mat[0, 3]
    return in_mat.astype(np.float32), ex_mat.astype(np.float32)

def h5_loader(path):
    h5f = h5py.File(path, "r")
    rgb = np.array(h5f['rgb'])
    rgb = np.transpose(rgb, (1, 2, 0))
    depth = np.array(h5f['depth'])
    norm = np.array(h5f['norm'])
    norm = np.transpose(norm, (1,2,0))
    valid_mask = np.array(h5f['mask'])

    return rgb, depth, norm, valid_mask
